
import yfinance as yf
import numpy as np
import matplotlib.pyplot as plt

# Download BTC-USD data

ticker = 'ETH-USD'
data = yf.download(ticker, start='2024-01-01', end='2025-01-01')

# Specifying parameters for trading
fee = 0.0005
sr_sell = 0.5
sr_buy = 0.5

# Coding technical analysis signals
data['returns'] = data['Close'].pct_change()
data['scaled price'] = data['Close'] / (10 ** np.floor(np.log10(data['Close'])))
data['S&R'] = data['scaled price'] % 1

# Simulating trading strategy
data['signal'] = (data['S&R'] < sr_buy).astype(int) - (data['S&R'] > sr_sell).astype(int)

# Shift signal to align with return calculation
BnH_return = data['returns'][1:].to_numpy()
SR_return = (data['returns'][1:].to_numpy() * data['signal'][:-1].to_numpy()) - (fee * abs(data['signal'][:-1].to_numpy()))

# Annualized return calculation
BnH = np.prod(1 + BnH_return) ** (252 / len(BnH_return)) - 1
SR = np.prod(1 + SR_return) ** (252 / len(SR_return)) - 1

# Risk calculation (Annualized volatility)
BnH_risk = np.std(BnH_return) * np.sqrt(252)
SR_risk = np.std(SR_return) * np.sqrt(252)

# Printing results
print(f'Buy-and-Hold Strategy Return and Risk: {round(BnH * 100, 2)}% and {round(BnH_risk * 100, 2)}%')
print(f'SR Strategy Return and Risk: {round(SR * 100, 2)}% and {round(SR_risk * 100, 2)}%')

# Visualizing results
plt.figure(figsize=(10, 5))
plt.plot(np.append(1, np.cumprod(1 + BnH_return)), label='Buy-and-Hold Strategy', linestyle='--')
plt.plot(np.append(1, np.cumprod(1 + SR_return)), label='SR Strategy', linestyle='-')
plt.legend()
plt.xlabel("Days")
plt.ylabel("Portfolio Value")
plt.title("Trading Strategy Performance")
plt.show()
